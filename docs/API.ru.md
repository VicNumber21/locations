# Описание API и примеры использования

Есть два вида API: CRUD и статистика.

Все виды СRUD предоставляются в двух видах:
  - пакетная обработка
  - единичные запросы

По статистике есть лишь один вид запроса, по сути являющимся пакетным.

## Запросы

### Пакетные запросы

Эти запросы позволяют одновременно создать, запросить, изменить или удалить несколько объектов локаций.

Это достигается за счёт следующих возможностей:
  - ввод данных происходит за счёт массива JSON объектов там, где имеет смысл тело запроса, или
    за счёт массива query параметров (достигается за счёт множественного использования одного и
    того же имени query парамтра с разными значениями) там, где смысла использовать тело запроса нет.
  - тело ответа возвращается в виде стрима (`transfer-encoding: chunked`) с целью потенциальной экономии
    памяти при исполнении запроса. По окончании передачи стрим преобразуется в массив JSON объектов.

Последнее накладывает ограничение на возможность обычного способа извещения об ошибках.
Дело в том, что при стримовом методе возврата данных, ответ на HTTP запрос приходит до начала обработки
этого запроса. При обнаружении ошибки после валидации входных данных вернуть код ошибки в виде HTTP
статуса уже нельзя (ответ уже отослан). Потому такие ошибки идут в теле ответа, заменяя объекты локаций,
на объекты ошибок.

Соответственно, положительный статус обработки запроса следует расценивать как отсутствие ошибок
во входных данных.

Также в данной реализации особенностью пакетных запросов является отсутствие в ответе объектов, для
которых запрос выполнить не удалось. Например, если при создании локаций для каких-то из них не
возвращается созданный объект, это следует расценивать как ошибку создания (для данного примера,
как статус Сonflict, потому что об остальных ошибочных случаях сообщается в явном виде).

### Одиночные запросы

Одиночные запросы являются более канонической формой RESTful API, потому их поведение полностью
соответствует ожиданиям от данного типа API.

Возможно единственным сюрпризом является возврат ошибок не только в виде HTTP статуса, но и в виде
JSON объекта. Это сделано для унификации поведения пакетного и одиночного видов API, а также для
предоставления дополнительной информации об ошибке.

## Данные

### Объекты локаций

Пример объекта локации:
```json
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  }
```

И в запросах и в ответах объекты локаций одинаковы за одним исключением: в запросах можно не указывать
время создания объекта, тогда автоматически будет подставлена текущие дата и время по UTC.

Расшифровка полей:
  - `id` - идентификатор локации. По заданию ограничен как `“^[a-zA-Z0-9]+$”`.
         Дополнительно было введено ограничение на длинну, максимальная `255`.
         Мне показалось, что для значений без пробелов и знаков препинания большая длина просто не
         имеет смысла (возможно стоит ограничить даже больше).
  - `longitude` - долгота, весщественное число от `-180` до `180` включительно.
                  Точность дальше 6 знака после точки не имеет смысла и приводит к округлениям.
                  Такая точность выбрана на основании анализа используемых значений в картах
                  Google и Яндекс.
  - `latitude` - широта, весщественное число от `-90` до `90` включительно.
                  Точность дальше 6 знака после точки не имеет смысла и приводит к округлениям.
                  Такая точность выбрана на основании анализа используемых значений в картах
                  Google и Яндекс.
  - `created` - таймстемп в виде ISO Date Time строка в UTC.

Про формат таймстемпа возможно стоит рассказать чуть подробнее. Выбор строкового представления
обусловлен тем, что работать с 64-битными числами в JavaScript достаточно неудобно из за того,
что для них нет естественной поддержки. Можно, конечно использовать BigInt, но это, опять же, не всегда удобно. В любом случаее, для пересылки придётся использовать строку, а не число.

Читать ISO строчку в разы удобнее, чем огромное число. К тому же её удобно генерировать с помощью
объекта `Date` (`(new Date()).toISOString()`, например), что позволяет использовать различную
математику дат.

Рамер же такой строчки, конечно, побольше, но не в десятки раз.
Потому я остановился на строковом представлении, хотя есть сомнения, что с этим будут согласны все.

Другим несколько спорным решением является то, что в таймстемп включены не только дата, но и время,
хотя в задании разговор идёт лишь о датах. В базу данных сохраняется полный таймстемп, но в запросах
таймстемпы округляются до даты, то есть время попросту отбрасывается. Это решение базируется на том,
что никакой экономии по размеру отбрасывание времени не несёт, а в будущем точное время создания
объекта может и пригодится.

Ну и наконец, обязательное UTC выбрано для однозначности времени. В этом случае нет ни проблем
глобального рапространения решения, ни проблем с зимним и летним временем.

### Объекты ошибок

Пример:
```json
   {
     "code": 500,
     "message": "Internal Server Error",
     "errorId": "68595e0e-d14a-42d3-8f30-29dfa93f09c6"
   }
```

Для ошибки возвращается её код, который идентичен статусу HTTP, сообщение и идентификатор ошибки.

В целях безопасности принято решение скрывать причину внутренних ошибок (как в примере),
потому для такой ошибки всегда возвращается сообщение "Internal Server Error". Для других типов
ошибок сообщения более осмысленны, типа:
```json
  {
    "code": 400,
    "message": "Invalid value of id",
    "errorId": "6a37e6fb-4d8a-46bf-abc3-83a1b9429e09"
  }
```

Идентификатор ошибки позволяет найти именно эту ошибку в логах и проследить, где она появилась:
на `api` или на `svc` ноде. Такое решение по моему замыслу должно упрощать анализ ошибок, так
убирает двусмысленность, о какой ошибке в данный момент идёт речь. Также это должно упрощать
использование таких инструментов, как Elastic Search.

## Примеры запросов и ответов

### Cоздание локации в пакетном режиме

Запрос 1
```bash
curl -X 'POST' \
  'http://localhost:8080/api/v1.0/locations' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location002",
    "longitude": 154.345987,
    "latitude": -23.654123
  },
  {
    "id": "location003",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  }
]'
```

Ответ 1
```json
[
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location002",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T09:37:27.931928Z"
  },
  {
    "id": "location003",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  }
]
```

В этом примере можно увидет как автоматическое определение даты, так и возможность задать нужную дату
вручную.

Запрос 2

```bash
curl -X 'POST' \
  'http://localhost:8080/api/v1.0/locations' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location004",
    "longitude": 154.345987,
    "latitude": -23.654123
  },
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  }
]'
```

Ответ 2

```json
[
  {
    "id": "location004",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T11:10:58.699243Z"
  },
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  }
]
```

Предполагается, что второй запрос проходит после первого. Это иллюстрация того, что объект
`"location001"` не создаётся, так как уже был создан при первом запросе.

### Создание локации в одиночном режиме

Запрос 1

```bash
curl -X 'POST' \
  'http://localhost:8080/api/v1.0/locations/single' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "longitude": 44.34598754252,
  "latitude": -33.65412356565
}'
```

Ответ 1

```json
{
  "id": "single",
  "longitude": 44.345988,
  "latitude": -33.654124,
  "created": "2023-04-18T11:16:13.633735Z"
}
```

В этом примере видно округление долготы и широты.

### Получение локаций в пакетном режиме

Запрос 1

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations' \
  -H 'accept: application/json'
```

Ответ 1

```json
[
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location002",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T09:37:27.931928Z"
  },
  {
    "id": "location003",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "location004",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T11:10:58.699243Z"
  },
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "single",
    "longitude": 44.345988,
    "latitude": -33.654124,
    "created": "2023-04-18T11:16:13.633735Z"
  }
]
```

Никаких фильтров не было указано, потому отданы все локации, которые на данный момент есть в базе.

Запрос 2

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations?from=2023-04-18T23%3A37%3A27.931928Z' \
  -H 'accept: application/json'
```

Ответ 2

```json
[
  {
    "id": "location002",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T09:37:27.931928Z"
  },
  {
    "id": "location004",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T11:10:58.699243Z"
  },
  {
    "id": "single",
    "longitude": 44.345988,
    "latitude": -33.654124,
    "created": "2023-04-18T11:16:13.633735Z"
  }
]
```

Теперь у локаций есть ограничение сверху, потому пришли лишь локации за 18е число.
Также можно обратить внимание, что все локации имеют время меньшее, чем в запросе.
Это иллюстрация того, что время, указанное в запросе, отбрасывается, важна лишь дата.

Запрос 3

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations?to=2023-04-17T23%3A37%3A27.931928Z' \
  -H 'accept: application/json'
```

Ответ 3

```json
[
  {
    "id": "location001",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location003",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  }
]
```

Теперь локации ограничены сверху.

Запрос 4

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations?from=2023-04-16T00%3A00Z&to=2023-04-18T00%3A00Z' \
  -H 'accept: application/json'
```

Ответ 4

```json
[
  {
    "id": "location002",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T09:37:27.931928Z"
  },
  {
    "id": "location03",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "location004",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-18T11:10:58.699243Z"
  },
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "single",
    "longitude": 44.345988,
    "latitude": -33.654124,
    "created": "2023-04-18T11:16:13.633735Z"
  }
]
```

Ограничение и сверху и снизу. В запросе, кстати, показано использование строк инимальной длины:
отброшены секунды и их части. Сделать строчку меньше не позволяет используемый формат таймстемпа.

Запрос 5

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations?id=location005&id=single&id=noSuchThing' \
  -H 'accept: application/json'
```

Ответ 5

```json
[
  {
    "id": "location005",
    "longitude": 154.345987,
    "latitude": -23.654123,
    "created": "2023-04-16T21:19:12.400032Z"
  },
  {
    "id": "single",
    "longitude": 44.345988,
    "latitude": -33.654124,
    "created": "2023-04-18T11:16:13.633735Z"
  }
]
```

Пример запроса нескольких локаций по идентификаторам. `"noSuchThing"` не была найдена, потому её в ответе нет.

Запрос 6

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations?from=2023-04-16T00%3A00Z&to=2023-04-18T00%3A00Z&id=location005&id=single' \
  -H 'accept: application/json'
```

Ответ 6

```json
{
  "code": 400,
  "message": "Invalid value (expected value to pass validation: It is not allowed to use id and timestamps filters simultaniously, but got: (Period(Some(2023-04-16T00:00Z),Some(2023-04-18T00:00Z)),Ids(List(location005, single))))",
  "errorId": "e43180dd-0420-4654-b0fe-659d9dffde62"
}
```

Пример использования двух фильтров одновременно. Было принято решение трактовать такую ситуацию,
как ошибочную, потому что это в общем-то не имеет смысла.

Тут видно, какого вида ошибка возвращается в подобных случаях, когда не удаётся пройти валидацию
входных данных.

### Получение локаций в одиночном режиме

Запрос 1

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations/single' \
  -H 'accept: application/json'
```

Ответ 1

```json
{
  "id": "single",
  "longitude": 44.345988,
  "latitude": -33.654124,
  "created": "2023-04-18T11:16:13.633735Z"
}
```

### Обновление локаций в пакетном режиме

Запрос 1

```bash
curl -X 'PUT' \
  'http://localhost:8080/api/v1.0/locations' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "id": "location001",
    "longitude": 0,
    "latitude": 0
  },
  {
    "id": "location002",
    "longitude": 1,
    "latitude": -1,
    "created": "2021-12-01T21:19:12.400032Z"
  }
]'
```

Ответ 1

```json
[
  {
    "id": "location001",
    "longitude": 0,
    "latitude": 0,
    "created": "2023-04-10T21:19:12.400032Z"
  },
  {
    "id": "location002",
    "longitude": 1,
    "latitude": -1,
    "created": "2023-04-18T09:37:27.931928Z"
  }
]
```

Пример иллюстрирует, что даже если указать время создания в запросе, при изменении оно не учитывается.

### Обновление локаций в одиночном режиме

Запрос 1

```bash
curl -X 'PUT' \
  'http://localhost:8080/api/v1.0/locations/single' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": "whatIfWeTrySomeIdHere",
  "longitude": 15,
  "latitude": -17
}'
```

Ответ 1

```json
{
  "id": "single",
  "longitude": 15,
  "latitude": -17,
  "created": "2023-04-18T11:16:13.633735Z"
}
```

Помимо одиночной модификации иллюстрируется то, что не имеющие смысла поля отбрасываются.
В данном случае `id` указано в URL, потому полностью игнорируется в теле запроса.

### Удаление в пакетном режиме

Запрос 1

```bash
curl -X 'DELETE' \
  'http://localhost:8080/api/v1.0/locations?id=location001&id=location005' \
  -H 'accept: */*'
```

Возвращается статус No Content (204), так как были найдены требуемые локации и произошло их удаление.

Запрос 2

```bash
curl -X 'DELETE' \
  'http://localhost:8080/api/v1.0/locations?id=meIsNotThere&id=meToo' \
  -H 'accept: */*'
```

Возвращается статус Ok (200). Ничего для удаления найдено не было, но в итоге получилась ситуациия,
при которых ненужных локаций в базе нет. То есть цель в целом была достигнута и нет смысла возврашать
код ошибки.

Запрос 3

```bash
curl -X 'DELETE' \
  'http://localhost:8080/api/v1.0/locations' \
  -H 'accept: */*'
```

Ответ 3

```json
{
  "code": 400,
  "message": "Invalid value for: query parameter id (expected size of value to be greater than or equal to 1, but got 0)",
  "errorId": "e5c75eef-47c9-41ff-ba50-766a56e74068"
}
```

Двусмысленная ситуация. Данный запрос может трактоваться как "удалить всё", так и "ничего не удалять".
Потому принято решение возвращать на него ошибку.

### Удаление в одиночном режиме

Запрос 1

```bash
curl -X 'DELETE' \
  'http://localhost:8080/api/v1.0/locations/single' \
  -H 'accept: */*'
```

Dозвращается статус No Content (204)

### Статистика

Запрос 1

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations/-/stats' \
  -H 'accept: application/json'
```

Ответ 1

```json
[
  {
    "date": "2023-04-10T00:00:00Z",
    "count": 1
  },
  {
    "date": "2023-04-16T00:00:00Z",
    "count": 2
  },
  {
    "date": "2023-04-18T00:00:00Z",
    "count": 3
  }
]
```

Когда нет фильтров, получаем статистику по всему, что находится в базе.

Запрос 2

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations/-/stats?from=2023-04-16T00%3A00%3A00Z' \
  -H 'accept: application/json'
```

Ответ 2

```json
[
  {
    "date": "2023-04-16T00:00:00Z",
    "count": 2
  },
  {
    "date": "2023-04-18T00:00:00Z",
    "count": 3
  }
]
```

Cтатистика ограничена снизу.

Запрос 3

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations/-/stats?to=2023-04-16T00%3A00%3A00Z' \
  -H 'accept: application/json'
```

Ответ 3

```json
[
  {
    "date": "2023-04-10T00:00:00Z",
    "count": 1
  },
  {
    "date": "2023-04-16T00:00:00Z",
    "count": 2
  }
]
```

Статистика ограничена сверху.

Запрос 4

```bash
curl -X 'GET' \
  'http://localhost:8080/api/v1.0/locations/-/stats?from=2023-04-16T00%3A00%3A00Z&to=2023-04-16T00%3A00%3A00Z' \
  -H 'accept: application/json'
```

Ответ 4

```json
[
  {
    "date": "2023-04-16T00:00:00Z",
    "count": 2
  }
]
```

Ограничение в двух сторон.
